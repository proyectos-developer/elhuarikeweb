{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport { loopAsync } from './AsyncUtils';\nimport { isPromise } from './PromiseUtils';\nimport { matchPattern } from './PatternUtils';\nimport warning from './routerWarning';\nimport { createRoutes } from './RouteUtils';\n\nfunction getChildRoutes(route, location, paramNames, paramValues, callback) {\n  if (route.childRoutes) {\n    return [null, route.childRoutes];\n  }\n\n  if (!route.getChildRoutes) {\n    return [];\n  }\n\n  var sync = true,\n      result = void 0;\n  var partialNextState = {\n    location: location,\n    params: createParams(paramNames, paramValues)\n  };\n  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {\n    childRoutes = !error && createRoutes(childRoutes);\n\n    if (sync) {\n      result = [error, childRoutes];\n      return;\n    }\n\n    callback(error, childRoutes);\n  });\n  if (isPromise(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {\n    return callback(null, createRoutes(childRoutes));\n  }, callback);\n  sync = false;\n  return result; // Might be undefined.\n}\n\nfunction getIndexRoute(route, location, paramNames, paramValues, callback) {\n  if (route.indexRoute) {\n    callback(null, route.indexRoute);\n  } else if (route.getIndexRoute) {\n    var partialNextState = {\n      location: location,\n      params: createParams(paramNames, paramValues)\n    };\n    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {\n      callback(error, !error && createRoutes(indexRoute)[0]);\n    });\n    if (isPromise(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {\n      return callback(null, createRoutes(indexRoute)[0]);\n    }, callback);\n  } else if (route.childRoutes || route.getChildRoutes) {\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n        return;\n      }\n\n      var pathless = childRoutes.filter(function (childRoute) {\n        return !childRoute.path;\n      });\n      loopAsync(pathless.length, function (index, next, done) {\n        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {\n          if (error || indexRoute) {\n            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);\n            done(error, routes);\n          } else {\n            next();\n          }\n        });\n      }, function (err, routes) {\n        callback(null, routes);\n      });\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\nfunction assignParams(params, paramNames, paramValues) {\n  return paramNames.reduce(function (params, paramName, index) {\n    var paramValue = paramValues && paramValues[index];\n\n    if (Array.isArray(params[paramName])) {\n      params[paramName].push(paramValue);\n    } else if (paramName in params) {\n      params[paramName] = [params[paramName], paramValue];\n    } else {\n      params[paramName] = paramValue;\n    }\n\n    return params;\n  }, params);\n}\n\nfunction createParams(paramNames, paramValues) {\n  return assignParams({}, paramNames, paramValues);\n}\n\nfunction matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {\n  var pattern = route.path || '';\n\n  if (pattern.charAt(0) === '/') {\n    remainingPathname = location.pathname;\n    paramNames = [];\n    paramValues = [];\n  } // Only try to match the path if the route actually has a pattern, and if\n  // we're not just searching for potential nested absolute paths.\n\n\n  if (remainingPathname !== null && pattern) {\n    try {\n      var matched = matchPattern(pattern, remainingPathname);\n\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n    } catch (error) {\n      callback(error);\n    } // By assumption, pattern is non-empty here, which is the prerequisite for\n    // actually terminating a match.\n\n\n    if (remainingPathname === '') {\n      var match = {\n        routes: [route],\n        params: createParams(paramNames, paramValues)\n      };\n      getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {\n        if (error) {\n          callback(error);\n        } else {\n          if (Array.isArray(indexRoute)) {\n            var _match$routes;\n\n            process.env.NODE_ENV !== 'production' ? warning(indexRoute.every(function (route) {\n              return !route.path;\n            }), 'Index routes should not have paths') : void 0;\n\n            (_match$routes = match.routes).push.apply(_match$routes, indexRoute);\n          } else if (indexRoute) {\n            process.env.NODE_ENV !== 'production' ? warning(!indexRoute.path, 'Index routes should not have paths') : void 0;\n            match.routes.push(indexRoute);\n          }\n\n          callback(null, match);\n        }\n      });\n      return;\n    }\n  }\n\n  if (remainingPathname != null || route.childRoutes) {\n    // Either a) this route matched at least some of the path or b)\n    // we don't have to load this route's children asynchronously. In\n    // either case continue checking for matches in the subtree.\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n      } else if (childRoutes) {\n        // Check the child routes to see if any of them match.\n        matchRoutes(childRoutes, location, function (error, match) {\n          if (error) {\n            callback(error);\n          } else if (match) {\n            // A child route matched! Augment the match and pass it up the stack.\n            match.routes.unshift(route);\n            callback(null, match);\n          } else {\n            callback();\n          }\n        }, remainingPathname, paramNames, paramValues);\n      } else {\n        callback();\n      }\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n/**\n * Asynchronously matches the given location to a set of routes and calls\n * callback(error, state) when finished. The state object will have the\n * following properties:\n *\n * - routes       An array of routes that matched, in hierarchical order\n * - params       An object of URL parameters\n *\n * Note: This operation may finish synchronously if no routes have an\n * asynchronous getChildRoutes method.\n */\n\n\nexport default function matchRoutes(routes, location, callback, remainingPathname) {\n  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n\n  if (remainingPathname === undefined) {\n    // TODO: This is a little bit ugly, but it works around a quirk in history\n    // that strips the leading slash from pathnames when using basenames with\n    // trailing slashes.\n    if (location.pathname.charAt(0) !== '/') {\n      location = _extends({}, location, {\n        pathname: '/' + location.pathname\n      });\n    }\n\n    remainingPathname = location.pathname;\n  }\n\n  loopAsync(routes.length, function (index, next, done) {\n    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {\n      if (error || match) {\n        done(error, match);\n      } else {\n        next();\n      }\n    });\n  }, callback);\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","loopAsync","isPromise","matchPattern","warning","createRoutes","getChildRoutes","route","location","paramNames","paramValues","callback","childRoutes","sync","result","partialNextState","params","createParams","childRoutesReturn","error","then","getIndexRoute","indexRoute","indexRoutesReturn","onChildRoutes","pathless","filter","childRoute","path","index","next","done","routes","concat","Array","isArray","err","apply","undefined","assignParams","reduce","paramName","paramValue","push","matchRouteDeep","remainingPathname","pattern","charAt","pathname","matched","match","_match$routes","process","env","NODE_ENV","every","matchRoutes","unshift"],"sources":["C:/Users/jppor/OneDrive/Documents/Proyectos/2021/elhuarike/web-app/node_modules/react-router/es/matchRoutes.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport { loopAsync } from './AsyncUtils';\nimport { isPromise } from './PromiseUtils';\nimport { matchPattern } from './PatternUtils';\nimport warning from './routerWarning';\nimport { createRoutes } from './RouteUtils';\n\nfunction getChildRoutes(route, location, paramNames, paramValues, callback) {\n  if (route.childRoutes) {\n    return [null, route.childRoutes];\n  }\n  if (!route.getChildRoutes) {\n    return [];\n  }\n\n  var sync = true,\n      result = void 0;\n\n  var partialNextState = {\n    location: location,\n    params: createParams(paramNames, paramValues)\n  };\n\n  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {\n    childRoutes = !error && createRoutes(childRoutes);\n    if (sync) {\n      result = [error, childRoutes];\n      return;\n    }\n\n    callback(error, childRoutes);\n  });\n\n  if (isPromise(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {\n    return callback(null, createRoutes(childRoutes));\n  }, callback);\n\n  sync = false;\n  return result; // Might be undefined.\n}\n\nfunction getIndexRoute(route, location, paramNames, paramValues, callback) {\n  if (route.indexRoute) {\n    callback(null, route.indexRoute);\n  } else if (route.getIndexRoute) {\n    var partialNextState = {\n      location: location,\n      params: createParams(paramNames, paramValues)\n    };\n\n    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {\n      callback(error, !error && createRoutes(indexRoute)[0]);\n    });\n\n    if (isPromise(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {\n      return callback(null, createRoutes(indexRoute)[0]);\n    }, callback);\n  } else if (route.childRoutes || route.getChildRoutes) {\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n        return;\n      }\n\n      var pathless = childRoutes.filter(function (childRoute) {\n        return !childRoute.path;\n      });\n\n      loopAsync(pathless.length, function (index, next, done) {\n        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {\n          if (error || indexRoute) {\n            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);\n            done(error, routes);\n          } else {\n            next();\n          }\n        });\n      }, function (err, routes) {\n        callback(null, routes);\n      });\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\nfunction assignParams(params, paramNames, paramValues) {\n  return paramNames.reduce(function (params, paramName, index) {\n    var paramValue = paramValues && paramValues[index];\n\n    if (Array.isArray(params[paramName])) {\n      params[paramName].push(paramValue);\n    } else if (paramName in params) {\n      params[paramName] = [params[paramName], paramValue];\n    } else {\n      params[paramName] = paramValue;\n    }\n\n    return params;\n  }, params);\n}\n\nfunction createParams(paramNames, paramValues) {\n  return assignParams({}, paramNames, paramValues);\n}\n\nfunction matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {\n  var pattern = route.path || '';\n\n  if (pattern.charAt(0) === '/') {\n    remainingPathname = location.pathname;\n    paramNames = [];\n    paramValues = [];\n  }\n\n  // Only try to match the path if the route actually has a pattern, and if\n  // we're not just searching for potential nested absolute paths.\n  if (remainingPathname !== null && pattern) {\n    try {\n      var matched = matchPattern(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n    } catch (error) {\n      callback(error);\n    }\n\n    // By assumption, pattern is non-empty here, which is the prerequisite for\n    // actually terminating a match.\n    if (remainingPathname === '') {\n      var match = {\n        routes: [route],\n        params: createParams(paramNames, paramValues)\n      };\n\n      getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {\n        if (error) {\n          callback(error);\n        } else {\n          if (Array.isArray(indexRoute)) {\n            var _match$routes;\n\n            process.env.NODE_ENV !== 'production' ? warning(indexRoute.every(function (route) {\n              return !route.path;\n            }), 'Index routes should not have paths') : void 0;\n            (_match$routes = match.routes).push.apply(_match$routes, indexRoute);\n          } else if (indexRoute) {\n            process.env.NODE_ENV !== 'production' ? warning(!indexRoute.path, 'Index routes should not have paths') : void 0;\n            match.routes.push(indexRoute);\n          }\n\n          callback(null, match);\n        }\n      });\n\n      return;\n    }\n  }\n\n  if (remainingPathname != null || route.childRoutes) {\n    // Either a) this route matched at least some of the path or b)\n    // we don't have to load this route's children asynchronously. In\n    // either case continue checking for matches in the subtree.\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n      } else if (childRoutes) {\n        // Check the child routes to see if any of them match.\n        matchRoutes(childRoutes, location, function (error, match) {\n          if (error) {\n            callback(error);\n          } else if (match) {\n            // A child route matched! Augment the match and pass it up the stack.\n            match.routes.unshift(route);\n            callback(null, match);\n          } else {\n            callback();\n          }\n        }, remainingPathname, paramNames, paramValues);\n      } else {\n        callback();\n      }\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\n/**\n * Asynchronously matches the given location to a set of routes and calls\n * callback(error, state) when finished. The state object will have the\n * following properties:\n *\n * - routes       An array of routes that matched, in hierarchical order\n * - params       An object of URL parameters\n *\n * Note: This operation may finish synchronously if no routes have an\n * asynchronous getChildRoutes method.\n */\nexport default function matchRoutes(routes, location, callback, remainingPathname) {\n  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n\n  if (remainingPathname === undefined) {\n    // TODO: This is a little bit ugly, but it works around a quirk in history\n    // that strips the leading slash from pathnames when using basenames with\n    // trailing slashes.\n    if (location.pathname.charAt(0) !== '/') {\n      location = _extends({}, location, {\n        pathname: '/' + location.pathname\n      });\n    }\n    remainingPathname = location.pathname;\n  }\n\n  loopAsync(routes.length, function (index, next, done) {\n    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {\n      if (error || match) {\n        done(error, match);\n      } else {\n        next();\n      }\n    });\n  }, callback);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}