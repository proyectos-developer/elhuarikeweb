{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nimport { matchPattern } from './PatternUtils';\n\nfunction deepEqual(a, b) {\n  if (a == b) return true;\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return deepEqual(item, b[index]);\n    });\n  }\n\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {\n    for (var p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue;\n      }\n\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false;\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false;\n      } else if (!deepEqual(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return String(a) === String(b);\n}\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\n\n\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = '/' + currentPathname;\n  } // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n\n\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/';\n  }\n\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/';\n  }\n\n  return currentPathname === pathname;\n}\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\n\n\nfunction routeIsActive(pathname, routes, params) {\n  var remainingPathname = pathname,\n      paramNames = [],\n      paramValues = []; // for...of would work here but it's probably slower post-transpilation.\n\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    var route = routes[i];\n    var pattern = route.path || '';\n\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname;\n      paramNames = [];\n      paramValues = [];\n    }\n\n    if (remainingPathname !== null && pattern) {\n      var matched = matchPattern(pattern, remainingPathname);\n\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every(function (paramName, index) {\n          return String(paramValues[index]) === String(params[paramName]);\n        });\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\n\n\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null) return query == null;\n  if (query == null) return true;\n  return deepEqual(query, activeQuery);\n}\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\n\n\nexport default function isActive(_ref, indexOnly, currentLocation, routes, params) {\n  var pathname = _ref.pathname,\n      query = _ref.query;\n  if (currentLocation == null) return false; // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname;\n  }\n\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false;\n    }\n  }\n\n  return queryIsActive(query, currentLocation.query);\n}","map":{"version":3,"names":["_typeof","Symbol","iterator","obj","constructor","prototype","matchPattern","deepEqual","a","b","Array","isArray","length","every","item","index","p","Object","hasOwnProperty","call","undefined","String","pathIsActive","pathname","currentPathname","charAt","routeIsActive","routes","params","remainingPathname","paramNames","paramValues","i","len","route","pattern","path","matched","concat","paramName","queryIsActive","query","activeQuery","isActive","_ref","indexOnly","currentLocation"],"sources":["C:/Users/jppor/OneDrive/Documents/Proyectos/2021/elhuarike/web-app/node_modules/react-router/es/isActive.js"],"sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nimport { matchPattern } from './PatternUtils';\n\nfunction deepEqual(a, b) {\n  if (a == b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return deepEqual(item, b[index]);\n    });\n  }\n\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {\n    for (var p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue;\n      }\n\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false;\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false;\n      } else if (!deepEqual(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return String(a) === String(b);\n}\n\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = '/' + currentPathname;\n  }\n\n  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/';\n  }\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/';\n  }\n\n  return currentPathname === pathname;\n}\n\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\nfunction routeIsActive(pathname, routes, params) {\n  var remainingPathname = pathname,\n      paramNames = [],\n      paramValues = [];\n\n  // for...of would work here but it's probably slower post-transpilation.\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    var route = routes[i];\n    var pattern = route.path || '';\n\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname;\n      paramNames = [];\n      paramValues = [];\n    }\n\n    if (remainingPathname !== null && pattern) {\n      var matched = matchPattern(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every(function (paramName, index) {\n          return String(paramValues[index]) === String(params[paramName]);\n        });\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null) return query == null;\n\n  if (query == null) return true;\n\n  return deepEqual(query, activeQuery);\n}\n\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\nexport default function isActive(_ref, indexOnly, currentLocation, routes, params) {\n  var pathname = _ref.pathname,\n      query = _ref.query;\n\n  if (currentLocation == null) return false;\n\n  // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname;\n  }\n\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false;\n    }\n  }\n\n  return queryIsActive(query, currentLocation.query);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}